using System;
using System.Diagnostics;

namespace Problem27
{
    // ReSharper disable once ClassNeverInstantiated.Global
    internal class Program
    {
        private static void Main()
        {
            Console.WriteLine("Problem 27");

            Test();

            const long upperLimit = 1000;
            (long, long, long) result = Solve(upperLimit);
            long a = result.Item1;
            long b = result.Item2;
            long maxPrimes = result.Item3;
            long product = a * b;

            Console.WriteLine($"a = {a}, b ={b}, maxPrimes = {maxPrimes}, product = {product}");

            Console.WriteLine("Done");
            Console.ReadKey();
        }

        // A sequence of length 71, is generated by a=-61, b=971, the product is -59231
        private static void Test()
        {
            TestAccessToModifiedClosure();

            Func<long, long> quadratic = n => n * n + 999 * n + 997;
            long maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 5);

            quadratic = n => n * n + n + 41;
            maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 40);

            quadratic = n => n * n - 39 * n - 23;
            maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 45);

            quadratic = n => n * n - 61 * n + 971;
            maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 71);

            quadratic = n => n * n - 79 * n + 1601;
            maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 80);

            quadratic = n => n * n - 999 * n - 999;
            maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 1000);

            quadratic = n => n * n - 999 * n + 61;
            maxPrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);
            Debug.Assert(maxPrimes == 1011);

            bool verified = VerifySolution(quadratic, maxPrimes);
            Debug.Assert(verified);
        }

        private static void TestAccessToModifiedClosure()
        {
            for (int n = 1; n < 5; n++)
            {
                for (int a = 1; a < 5; a++)
                {
                    //long quadratic(long m) => m * m + a * m + 1;
                    Func<long, long> quadratic = m => m * m + a * m + 1;
                    long value = quadratic(n);
                    Console.WriteLine($"n = {n}, a = {a}, value = {value}");
                }
            }
        }

        private static (long, long, long) Solve(long upperLimit)
        {
            long maxConsecutivePrimes = 0;
            long aValue = 0;
            long bValue = 0;

            for (long a = -upperLimit + 1; a < upperLimit; a++)
            {
                for (long b = -upperLimit; b <= upperLimit; b++)
                {
                    CheckConstraints(upperLimit, a, b);
                    //long Quadratic(long n) => n * n + a * n + b;
                    Func<long, long> quadratic = n => n * n + a * n + b;
                    long numberConsecutivePrimes = FindNumberConsecutivePrimesForQuadratic(quadratic);

                    // ReSharper disable once InvertIf
                    if (numberConsecutivePrimes > maxConsecutivePrimes)
                    {
                        maxConsecutivePrimes = numberConsecutivePrimes;
                        aValue = a;
                        bValue = b;

                        Console.WriteLine($"a = {a, 6}, b = {b, 6}, maxPrimes = {maxConsecutivePrimes, 10}");

                        bool verified = VerifySolution(quadratic, numberConsecutivePrimes);
                        if (!verified)
                        {
                            Console.WriteLine("Solution verification failed");
                        }
                    }
                }
            }

            return (aValue, bValue, maxConsecutivePrimes);
        }

        //private static long Quadratic(long n, long a, long b) => n * n + a * n + b;

        private static bool VerifySolution(Func<long, long> quadratic, long numberPrimes)
        {
            for (int n = 0; n < numberPrimes; n++)
            {
                long value = quadratic(n);

                if (!IsPrime(value))
                {
                    return false;
                }
            }

            return true;
        }

        //private static (long, long, long) Solve2(long upperLimit)
        //{
        //    long maxPrimes = 0;
        //    long aValue = 0;
        //    long bValue = 0;

        //    for (long a = -upperLimit; a <= upperLimit; a++)
        //    {
        //        for (long b = -upperLimit; b <= upperLimit; b++)
        //        {
        //            CheckConstraints(upperLimit, a, b);
        //            Func<long, long> Quadratic = n => n * n + a * n + b;
        //            long numberPrimes = FindMaxNumberPrimesForQuadratic(Quadratic);

        //            if (numberPrimes > maxPrimes)
        //            {
        //                maxPrimes = numberPrimes;
        //                aValue = a;
        //                bValue = b;

        //                Console.WriteLine($"aValue = {aValue, 6}, bValue = {bValue, 6}, maxPrimes = {maxPrimes, 10}");
        //            }
        //        }
        //    }

        //    return (aValue, bValue, maxPrimes);
        //}

        private static void CheckConstraints(long upperLimit, long a, long b)
        {
            bool assertion = Math.Abs(a) < upperLimit && Math.Abs(b) <= upperLimit;

            if (!assertion)
            {
                Console.WriteLine($"Assertion failed for a = {a, 6} and b = {b, 6}");
            }
        }

        private static long FindNumberConsecutivePrimesForQuadratic(Func<long, long> quadratic)
        {
            long numberPrimes = 0;
            long number = 0;

            while (true)
            {
                long value = quadratic(number);

                if (!IsPrime(value))
                {
                    break;    
                }

                number++;
                numberPrimes++;
            }

            return numberPrimes;
        }

        private static bool IsPrime(long candidate)
        {
            if ((candidate & 1) == 0)
            {
                return candidate == 2;
            }

            for (long i = 3; i * i <= candidate; i += 2)
            {
                if (candidate % i == 0)
                {
                    return false;
                }
            }

            return candidate != 1;
        }
    }
}
